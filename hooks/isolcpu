#!/usr/bin/env bash

#
# Filename:       /etc/libvirt/hooks/isolcpu
# Description:    Reserve/release CPU threads at start of Libvirt domain(s).
# URL(s):         https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#IO\_threads
# Author(s):      Alex Portell <codeberg.org/portellam> <github.com/portellam>
# Maintainer(s):  Alex Portell <codeberg.org/portellam> <github.com/portellam>
# Version:        1.0.0
#

#
# Save output to string for cpuset and cpumask
# Example:
#   Host:   0-1,8-9
#   Domain: 2-7,10-15
#
# Information
# cores     bit masks       mask
# 0-7       0b11111111      FF    # total cores
# 0,4       0b00010001      11    # host cores
#
# 0-11      0b111111111111  FFF   # total cores
# 0-1,6-7   0b000011000011  C3    # host cores
#
#

#
# params
#
  OPERATION="${2}"

  #
  # DESC: append output
  #
    PREFIX_PROMPT="libvirt-qemu $( basename "${0}" )"
    PREFIX_ERROR="${PREFIX_PROMPT}An error occurred: "
    PREFIX_FAIL="${PREFIX_PROMPT}Failure: "
    PREFIX_PASS="${PREFIX_PROMPT}Success: "
    PREFIX_SKIP="${PREFIX_PROMPT}Skipped: "

  FLAG_USE_HEX_MASKS=true
  GUEST_THREADS_DELIM=""
  GUEST_THREADS_HEX=""
  HOST_THREADS_DELIM=""
  HOST_THREADS_HEX=""

#
# logic
#
  function main
  {
    local -r str_output="Dynamic Isolcpu"

    log_output "${str_output}"

    if does_grub_have_isolcpu_setting; then
      log_skip "${str_output}"
      return 0
    fi

    if ! get_cpu \
      || ! release_or_reserve_cpu; then
      log_fail "${str_output}"
      return 1
    fi

    log_pass "${str_output}"
    return 0
  }

  #
  # DESC: loggers
  #
    #
    # DESC:   Log the output as an error.
    # $1:     the output as a string.
    # RETURN: Always return 0.
    #
      function log_error
      {
        echo -e "${PREFIX_ERROR}${1}" >&2
        return 0
      }

    #
    # DESC:   Log the output as a fail.
    # $1:     the output as a string.
    # RETURN: Always return 0.
    #
      function log_fail
      {
        echo -e "${PREFIX_FAIL}${1}" >&2
        return 0
      }

    #
    # DESC:   Log the output as a fail.
    # $1:     the output as a string.
    # RETURN: Always return 0.
    #
      function log_output
      {
        echo -e "${PREFIX_PROMPT}${1}" >&1
        return 0
      }

    #
    # DESC:   Log the output as a pass.
    # $1:     the output as a string.
    # RETURN: Always return 0.
    #
      function log_pass
      {
        echo -e "${PREFIX_PASS}${1}" >&1
        return 0
      }

    #
    # DESC:   Log the output as a skip.
    # $1:     the output as a string.
    # RETURN: Always return 0.
    #
      function log_skip
      {
        echo -e "${PREFIX_SKIP}${1}" >&1
        return 0
      }

  #
  # DESC: validation
  #
    function are_values_not_empty
    {
      if ( \
          "${FLAG_USE_HEX_MASKS}" \
          && are_hex_masks_not_empty \
          && are_thread_sets_not_empty \
        ) || ( \
          ! "${FLAG_USE_HEX_MASKS}" \
          && are_thread_sets_not_empty \
        ); then
        return 0
      fi

      return 1
    }

    function are_hex_masks_not_empty
    {
      if [[ -z "${GUEST_THREADS_HEX}" ]] \
        || [[ -z "${HOST_THREADS_HEX}" ]]; then
        log_error "Failed to get CPU hexadecimal masks."
        return 1
      fi
    }

    function are_thread_sets_not_empty
    {
      if [[ -z "${GUEST_THREADS_DELIM}" ]] \
        || [[ -z "${HOST_THREADS_DELIM}" ]]; then
        log_error "Failed to get CPU thread sets."
        return 1
      fi
    }

    function does_grub_have_isolcpu_setting
    {
      local -r grub_cmdline="$( cat /etc/default/grub | "\
        "grep GRUB_CMDLINE_LINUX_DEFAULT | cut --delimiter '"' --fields 2 )"

      case "${grub_cmdline}" in
        *"isolcpus="* | *"nohz_full="* | *"rcu_nocbs="* )
          log_output "Static Isolcpu found in GRUB."
          return 0 ;;
      esac

      return 1
    }

  #
  # DESC: getters
  #
    function get_cpu
    {
      are_values_not_empty &> /dev/null && return 0

      local -i cores_allocated_to_host=0

      local -i total_cores_count=$( \
        cat /proc/cpuinfo | grep "cpu cores" | uniq | grep -o "[0-9]\+" \
      )

      local -i total_threads_count=$( \
        cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" \
      )

      if ! set_cores_allocated_to_host; then
        return 1
      fi

      local -a host_cores_list=( $( seq 0 $(( "${cores_allocated_to_host}" - 1 )) ) )

      local -a guest_cores_list=( \
        $( seq "${cores_allocated_to_host}" $(( "${total_cores_count}" - 1 )) ) \
      )

      local -i smt_factor=$(( "${total_threads_count}" / "${total_cores_count}" ))
      local -a smt_factor_list=( $( seq 0 $(( "${smt_factor}" - 1 )) ) )

      if ! get_thread_sets_for_host_and_libvirt \
        || ! get_hex_mask_for_host_and_libvirt \
        || ! are_values_not_empty; then
        return 1
      fi

      return 0
    }

    function get_hex_mask_for_host_and_libvirt
    {
      local -i host_threads_hex_mask=0
      local -i total_threads_hex_mask=0

      #
      # Add each decimal mask to sum.
      #
      for thread in ${host_threads_list[@]}; do
        local -i thread_decimal=$(( 2 ** ${thread} ))
        local -i thread_hex_mask=$( echo "obase=16; ${thread_decimal}" | bc )
        host_threads_hex_mask+="${thread_hex_mask}"
      done

      #
      # Convert hexadecimal mask into hexadecimal.
      #
        HOST_THREADS_HEX=$( printf '%x\n' "${host_threads_hex_mask}" )
        local -i total_threads_hex_mask=$(( ( 2 ** ${total_threads_count} ) - 1 ))
        GUEST_THREADS_HEX=$( printf '%x\n' "${total_threads_hex_mask}" )
    }

    function get_thread_by_core_and_smt
    {
      thread=$(( core + ( smt_factor * total_cores_count )))
    }

    function get_thread_sets_for_host_and_libvirt
    {
      for smt_factor in ${smt_factor_list[@]}; do
        local -a guest_threads_delim_list=( )
        local -a host_threads_delim_list=( )
        local -i thread

        add_threads_to_lists

        local -i first_thread_set="${host_threads_delim_list[0]}"
        local -i last_thread_set="${host_threads_delim_list[-1]}"

        local thread_set="${first_thread_set}"

        if [[ "${first_thread_set}" -ne "${last_thread_set}" ]]; then
          local thread_set="${first_thread_set}-${last_thread_set}"
        fi

        HOST_THREADS_DELIM+="${thread_set},"

        local -i first_thread_set="${guest_threads_delim_list[0]}"
        local -i last_thread_set="${guest_threads_delim_list[-1]}"
        local thread_set="${first_thread_set}"

        if [[ "${first_thread_set}" -ne "${thread_set}" ]]; then
          local thread_set="${first_thread_set}-${last_thread_set}"
        fi

        GUEST_THREADS_DELIM+="${thread_set},"
      done

      are_thread_sets_not_empty || return 1

      #
      # Truncate last delimiter
      #
        if [[ ${HOST_THREADS_DELIM: -1} == "," ]]; then
          HOST_THREADS_DELIM="${HOST_THREADS_DELIM::-1}"
        fi

        if [[ ${GUEST_THREADS_DELIM: -1} == "," ]]; then
          GUEST_THREADS_DELIM="${GUEST_THREADS_DELIM::-1}"
        fi

      return 0
    }

  #
  # DESC: Release/Reserve
  #
    function release_hex_mask
    {
      if ! echo "${HOST_THREADS_HEX}" > /sys/bus/workqueue/devices/writeback/cpumask \
        || ! echo 0 > /sys/bus/workqueue/devices/writeback/numa; then
        log_error "Failed to release CPU mask to Host."
        return 1
      fi

      log_output "Releasing CPU mask to Host."
      return 0
    }

    function release_operation
    {
      if "${FLAG_USE_HEX_MASKS}" \
        && ! release_hex_mask; then
        return 1
      fi

      local -i last_thread_id=$( \
        cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" \
      )

      (( last_thread_id-- ))
      local release_cpu_set="0-${last_thread_id}"
      release_thread_sets "${release_cpu_set}"
    }

    function release_thread_sets
    {
      local cpu_set="${1}"

      if ! systemctl set-property --runtime -- system.slice AllowedCPUs="${cpu_set}" \
        || ! systemctl set-property --runtime -- user.slice AllowedCPUs="${cpu_set}" \
        || ! systemctl set-property --runtime -- \
          init.scope AllowedCPUs="${cpu_set}"; then
        log_error "Failed to release CPU threads to Host."
        return 1
      fi

      log_output "Releasing CPU threads to Host."
      return 0
    }

    function reserve_hex_mask
    {
      if ! echo "${GUEST_THREADS_HEX}" > \
          /sys/bus/workqueue/devices/writeback/cpumask \
        || ! echo 1 > /sys/bus/workqueue/devices/writeback/numa; then
        log_error "Failed to reserve CPU mask to Libvirt domain(s)."
        return 1
      fi

      log_output "Reserving CPU mask to Libvirt domain(s)."
      return 0
    }

    function reserve_operation
    {
      if "${FLAG_USE_HEX_MASKS}" \
        || ! reserve_hex_mask \
        || ! reserve_thread_sets; then
        return 1
      fi

      return 0
    }

    function reserve_thread_sets
    {
      if ! systemctl set-property --runtime -- system.slice \
          AllowedCPUs="${GUEST_THREADS_DELIM}" \
        || ! systemctl set-property --runtime -- user.slice \
          AllowedCPUs="${GUEST_THREADS_DELIM}" \
        || ! systemctl set-property --runtime -- init.scope \
          AllowedCPUs="${GUEST_THREADS_DELIM}"; then
        log_error "Failed to reserve CPU threads to Libvirt domain(s)."
        return 1
      fi

      log_output "Reserving CPU threads to Libvirt domain(s)."
      return 0
    }

    function release_or_reserve_cpu
    {
      case "${OPERATION}" in
        "started" | "release" )
          if ! reserve_operation; then
            return 1
          fi
          ;;
      esac

      return 0
    }

  #
  # DESC: setters
  #
    function add_threads_to_lists
    {
      add_threads_to_host_list
      add_threads_to_guest_list
    }

    function add_threads_to_guest_list
    {
      for core in ${guest_cores_list[@]}; do
        get_thread_by_core_and_smt
        guest_threads_list+=( "${thread}" )
        guest_threads_delim_list+=( "${thread}" )
      done
    }

    function add_threads_to_host_list
    {
      for core in ${host_cores_list[@]}; do
        get_thread_by_core_and_smt
        host_threads_list+=( "${thread}" )
        host_threads_delim_list+=( "${thread}" )
      done

      return 0
    }

    function set_cores_allocated_to_host
    {
      if [[ "${total_cores_count}" -ge 4 ]]; then
        cores_allocated_to_host=2

      elif [[ "${total_cores_count}" -le 3 ]] \
        && [[ "${total_cores_count}" -ge 2 ]]; then
        cores_allocated_to_host=1

      else
        log_error "Insufficient CPU cores. Minimum is two (2) cores."
        return 1
      fi

      return 0
    }

#
# main
#
  main